# name: test/sql/stats/count_star_optimization.test
# description: Test metadata-only COUNT(*) optimization
# group: [stats]

require ducklake

require parquet

test-env DUCKLAKE_CONNECTION __TEST_DIR__/{UUID}.db

test-env DATA_PATH __TEST_DIR__

statement ok
ATTACH 'ducklake:${DUCKLAKE_CONNECTION}' AS ducklake (DATA_PATH '${DATA_PATH}/count_star_optimization')

# create table and insert data
statement ok
CREATE TABLE ducklake.test(i INTEGER);

statement ok
INSERT INTO ducklake.test FROM range(1000);

# basic COUNT(*) should return correct count
query I
SELECT COUNT(*) FROM ducklake.test;
----
1000

# insert more data (non-overlapping range)
statement ok
INSERT INTO ducklake.test FROM range(1000, 1500);

query I
SELECT COUNT(*) FROM ducklake.test;
----
1500

# test COUNT(*) with uncommitted inserts
statement ok
BEGIN;

statement ok
INSERT INTO ducklake.test FROM range(2000, 2200);

query I
SELECT COUNT(*) FROM ducklake.test;
----
1700

statement ok
ROLLBACK;

query I
SELECT COUNT(*) FROM ducklake.test;
----
1500

# test COUNT(*) with uncommitted deletes (no prior committed deletes on this data)
statement ok
BEGIN;

statement ok
DELETE FROM ducklake.test WHERE i >= 400 AND i < 500;

query I
SELECT COUNT(*) FROM ducklake.test;
----
1400

statement ok
ROLLBACK;

query I
SELECT COUNT(*) FROM ducklake.test;
----
1500

# test with committed deletes
statement ok
DELETE FROM ducklake.test WHERE i < 100;

query I
SELECT COUNT(*) FROM ducklake.test;
----
1400

# test transaction-local table (newly created table)
statement ok
BEGIN;

statement ok
CREATE TABLE ducklake.new_table(x INTEGER);

statement ok
INSERT INTO ducklake.new_table FROM range(50);

query I
SELECT COUNT(*) FROM ducklake.new_table;
----
50

statement ok
COMMIT;

query I
SELECT COUNT(*) FROM ducklake.new_table;
----
50

# ============================================
# Test with inlined data
# ============================================

statement ok
DETACH ducklake;

statement ok
ATTACH 'ducklake:${DUCKLAKE_CONNECTION}_inlined' AS ducklake (DATA_PATH '${DATA_PATH}/count_star_inlined', DATA_INLINING_ROW_LIMIT 100)

# create table with inlined data (small enough to be inlined)
statement ok
CREATE TABLE ducklake.inlined_test AS SELECT * FROM range(50) t(i);

query I
SELECT COUNT(*) FROM ducklake.inlined_test;
----
50

# insert more inlined data
statement ok
INSERT INTO ducklake.inlined_test FROM range(50, 80);

query I
SELECT COUNT(*) FROM ducklake.inlined_test;
----
80

# delete from inlined data
statement ok
DELETE FROM ducklake.inlined_test WHERE i < 10;

query I
SELECT COUNT(*) FROM ducklake.inlined_test;
----
70

# test with uncommitted inlined inserts
statement ok
BEGIN;

statement ok
INSERT INTO ducklake.inlined_test FROM range(100, 120);

query I
SELECT COUNT(*) FROM ducklake.inlined_test;
----
90

statement ok
ROLLBACK;

query I
SELECT COUNT(*) FROM ducklake.inlined_test;
----
70

# test with uncommitted inlined deletes
statement ok
BEGIN;

statement ok
DELETE FROM ducklake.inlined_test WHERE i >= 70;

query I
SELECT COUNT(*) FROM ducklake.inlined_test;
----
60

statement ok
ROLLBACK;

query I
SELECT COUNT(*) FROM ducklake.inlined_test;
----
70

# ============================================
# Test time travel after merge_adjacent_files
# ============================================

statement ok
DETACH ducklake;

statement ok
ATTACH 'ducklake:${DATA_PATH}/merge_meta.db' AS ducklake (DATA_PATH '${DATA_PATH}/merge_data')

# create table and insert data in multiple batches to create multiple files
statement ok
CREATE TABLE ducklake.merge_test(i INTEGER);

statement ok
INSERT INTO ducklake.merge_test FROM range(100);

# record snapshot after first insert (should have 100 rows)
query I
SELECT MAX(snapshot_id) FROM ducklake.snapshots();
----
2

statement ok
INSERT INTO ducklake.merge_test FROM range(100, 200);

statement ok
INSERT INTO ducklake.merge_test FROM range(200, 300);

# current count should be 300
query I
SELECT COUNT(*) FROM ducklake.merge_test;
----
300

# run merge to create a file with partial_max
statement ok
CALL ducklake_merge_adjacent_files('ducklake', 'merge_test');

# current count should still be 300
query I
SELECT COUNT(*) FROM ducklake.merge_test;
----
300

# time travel to snapshot 2 should return 100, not 300
# this verifies we fall back to scanning for time travel queries
query I
SELECT COUNT(*) FROM ducklake.merge_test AT (VERSION => 2);
----
100

# time travel to snapshot 3 should return 200
query I
SELECT COUNT(*) FROM ducklake.merge_test AT (VERSION => 3);
----
200

# ============================================
# Test attaching at historical snapshot
# ============================================

# detach and re-attach at snapshot 2
statement ok
DETACH ducklake;

statement ok
ATTACH 'ducklake:${DATA_PATH}/merge_meta.db' AS ducklake_v2 (DATA_PATH '${DATA_PATH}/merge_data', SNAPSHOT_VERSION 2)

# COUNT(*) should return 100 (the count at snapshot 2), not 300
query I
SELECT COUNT(*) FROM ducklake_v2.merge_test;
----
100

# detach v2 and attach at snapshot 3
statement ok
DETACH ducklake_v2;

statement ok
ATTACH 'ducklake:${DATA_PATH}/merge_meta.db' AS ducklake_v3 (DATA_PATH '${DATA_PATH}/merge_data', SNAPSHOT_VERSION 3)

query I
SELECT COUNT(*) FROM ducklake_v3.merge_test;
----
200
