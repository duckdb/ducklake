# name: test/sql/stats/complex_filter_pushdown.test
# description: Comprehensive tests for complex filter pushdown with statistics
# group: [stats]

require ducklake

require parquet

test-env DUCKLAKE_CONNECTION __TEST_DIR__/{UUID}.db

test-env DATA_PATH __TEST_DIR__

statement ok
ATTACH 'ducklake:${DUCKLAKE_CONNECTION}' AS ducklake (DATA_PATH '${DATA_PATH}/ducklake_complex_filter_pushdown_files')

# Create comprehensive test table with multiple columns for cross-column equality testing
statement ok
CREATE TABLE ducklake.filter_test (
    -- Integer columns with different ranges for testing comparisons
    id INTEGER,           -- Range: 0-999 (across multiple files)
    category INTEGER,     -- Range: 1-5 (predictable distribution)
    user_id INTEGER,      -- Range: 100-500 (for testing cross-column equality)
    group_id INTEGER,     -- Range: 100-500 (overlaps with user_id for equality tests)
    
    -- String columns for string-based filtering
    name VARCHAR,         -- Mix of common/rare values
    status VARCHAR,       -- Limited set: 'active', 'inactive', 'pending', NULL
    department VARCHAR,   -- Limited set for cross-column equality tests
    location VARCHAR,     -- Some values match department for equality testing
    
    -- Numeric types for precision testing
    price DECIMAL(10,2),  -- Range: 0.01-999.99
    score DOUBLE,         -- Range: 0.0-100.0 with some NaN values
    rating DOUBLE,        -- Range: 1.0-5.0 (for cross-column numeric equality)
    
    -- Null handling columns
    optional_field INTEGER,  -- High null percentage (~50%)
    required_field INTEGER,  -- Low null percentage (~5%)
    
    -- Date/timestamp for temporal filtering
    created_at TIMESTAMP,
    updated_at TIMESTAMP  -- For testing temporal equality conditions
);

# File 1: id=0-199, category=1-2, user_id=100-149, group_id=100-149, department='Engineering', location='Building A', high nulls in optional_field
statement ok
INSERT INTO ducklake.filter_test
SELECT 
    i as id,
    (i % 2) + 1 as category,
    100 + (i % 50) as user_id,
    100 + (i % 50) as group_id,
    'name_' || (i % 10) as name,
    CASE WHEN i % 4 = 0 THEN 'active' WHEN i % 4 = 1 THEN 'inactive' WHEN i % 4 = 2 THEN 'pending' ELSE NULL END as status,
    'Engineering' as department,
    'Building A' as location,
    (i * 2.5)::DECIMAL(10,2) as price,
    (i * 0.5) as score,
    ((i % 5) + 1)::DOUBLE as rating,
    CASE WHEN i % 2 = 0 THEN NULL ELSE i END as optional_field,  -- 50% nulls
    CASE WHEN i % 20 = 0 THEN NULL ELSE i END as required_field,  -- 5% nulls
    TIMESTAMP '2023-01-01' + INTERVAL (i) DAY as created_at,
    TIMESTAMP '2023-01-01' + INTERVAL (i) DAY as updated_at
FROM range(200) t(i);

# File 2: id=200-399, category=2-3, user_id=150-249, group_id=200-299, department='Sales', location='Building B', medium nulls
statement ok
INSERT INTO ducklake.filter_test
SELECT 
    i as id,
    ((i % 2) + 2) as category,
    150 + (i % 100) as user_id,
    200 + (i % 100) as group_id,
    'name_' || ((i + 5) % 10) as name,
    CASE WHEN i % 4 = 0 THEN 'active' WHEN i % 4 = 1 THEN 'inactive' WHEN i % 4 = 2 THEN 'pending' ELSE NULL END as status,
    'Sales' as department,
    'Building B' as location,
    (i * 1.8)::DECIMAL(10,2) as price,
    (i * 0.4) as score,
    ((i % 5) + 1)::DOUBLE as rating,
    CASE WHEN i % 3 = 0 THEN NULL ELSE i END as optional_field,  -- 33% nulls
    CASE WHEN i % 25 = 0 THEN NULL ELSE i END as required_field,  -- 4% nulls
    TIMESTAMP '2023-01-01' + INTERVAL (i) DAY as created_at,
    TIMESTAMP '2023-01-01' + INTERVAL (i + 10) DAY as updated_at
FROM range(200, 400) t(i);

# File 3: id=400-599, category=3-4, user_id=250-349, group_id=250-349, department='Marketing', location='Building A', low nulls  
statement ok
INSERT INTO ducklake.filter_test
SELECT 
    i as id,
    ((i % 2) + 3) as category,
    250 + (i % 100) as user_id,
    250 + (i % 100) as group_id,
    'name_' || ((i + 10) % 10) as name,
    CASE WHEN i % 4 = 0 THEN 'active' WHEN i % 4 = 1 THEN 'inactive' WHEN i % 4 = 2 THEN 'pending' ELSE NULL END as status,
    'Marketing' as department,
    'Building A' as location,
    (i * 1.2)::DECIMAL(10,2) as price,
    (i * 0.3) as score,
    ((i % 5) + 1)::DOUBLE as rating,
    CASE WHEN i % 4 = 0 THEN NULL ELSE i END as optional_field,  -- 25% nulls
    CASE WHEN i % 30 = 0 THEN NULL ELSE i END as required_field,  -- 3.3% nulls
    TIMESTAMP '2023-01-01' + INTERVAL (i) DAY as created_at,
    TIMESTAMP '2023-01-01' + INTERVAL (i) DAY as updated_at
FROM range(400, 600) t(i);

# File 4: id=600-799, category=4-5, user_id=350-449, group_id=400-499, department='Engineering', location='Building C', mixed nulls
statement ok
INSERT INTO ducklake.filter_test
SELECT 
    i as id,
    ((i % 2) + 4) as category,
    350 + (i % 100) as user_id,
    400 + (i % 100) as group_id,
    'name_' || ((i + 15) % 10) as name,
    CASE WHEN i % 4 = 0 THEN 'active' WHEN i % 4 = 1 THEN 'inactive' WHEN i % 4 = 2 THEN 'pending' ELSE NULL END as status,
    'Engineering' as department,
    'Building C' as location,
    (i * 0.8)::DECIMAL(10,2) as price,
    (i * 0.2) as score,
    ((i % 5) + 1)::DOUBLE as rating,
    CASE WHEN i % 3 = 0 THEN NULL ELSE i END as optional_field,  -- 33% nulls
    CASE WHEN i % 20 = 0 THEN NULL ELSE i END as required_field,  -- 5% nulls
    TIMESTAMP '2023-01-01' + INTERVAL (i) DAY as created_at,
    TIMESTAMP '2023-01-01' + INTERVAL (i - 5) DAY as updated_at
FROM range(600, 800) t(i);

# File 5: id=800-999, category=1,5, user_id=400-500, group_id=100-200, department='Sales', location='Building B', sparse data with gaps
statement ok
INSERT INTO ducklake.filter_test
SELECT 
    i as id,
    CASE WHEN i % 2 = 0 THEN 1 ELSE 5 END as category,
    400 + (i % 100) as user_id,
    100 + (i % 100) as group_id,
    'name_' || ((i + 20) % 10) as name,
    CASE WHEN i % 4 = 0 THEN 'active' WHEN i % 4 = 1 THEN 'inactive' WHEN i % 4 = 2 THEN 'pending' ELSE NULL END as status,
    'Sales' as department,
    'Building B' as location,
    (i * 0.6)::DECIMAL(10,2) as price,
    CASE WHEN i % 10 = 0 THEN 'NaN'::DOUBLE ELSE (i * 0.1) END as score,  -- Include some NaN values
    ((i % 5) + 1)::DOUBLE as rating,
    CASE WHEN i % 5 = 0 THEN NULL ELSE i END as optional_field,  -- 20% nulls
    CASE WHEN i % 15 = 0 THEN NULL ELSE i END as required_field,  -- 6.7% nulls
    TIMESTAMP '2023-01-01' + INTERVAL (i) DAY as created_at,
    TIMESTAMP '2023-01-01' + INTERVAL (i + 20) DAY as updated_at
FROM range(800, 1000) t(i);

# ===== FilterCombiner Integration Tests =====

# Test 1.1: Simple Expressions Handled by FilterCombiner
# These should be fully handled by FilterCombiner without fallback to recursive processing

# Simple integer equality
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100;
----
1

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100;
----
analyzed_plan	<REGEX>:.*Total Files Read: 1.*

# Simple integer range
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id > 500;
----
499

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id > 500;
----
analyzed_plan	<REGEX>:.*Total Files Read: 3.*

# BETWEEN clause  
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id BETWEEN 200 AND 400;
----
201

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id BETWEEN 200 AND 400;
----
analyzed_plan	<REGEX>:.*Total Files Read: 2.*

# String equality
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE department = 'Engineering';
----
400

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE department = 'Engineering';
----
analyzed_plan	<REGEX>:.*Total Files Read: 2.*

# Decimal comparison
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE price >= 50.00;
----
980

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE price >= 50.00;
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# Test 1.2: FilterCombiner Unsatisfiable Detection
# These should be detected as impossible by FilterCombiner and return early with is_unsatisfiable=true

# Impossible equality condition
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 AND id = 200;
----
0

query I
SELECT id FROM ducklake.filter_test WHERE id = 100 AND id = 200;
----


query II
EXPLAIN ANALYZE SELECT id FROM ducklake.filter_test WHERE id = 100 AND id = 200;
----
analyzed_plan	<REGEX>:.*EMPTY_RESULT.*

# Impossible range condition
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id > 900 AND id < 100;
----
0

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id > 900 AND id < 100;
----
analyzed_plan	<REGEX>:.*EMPTY_RESULT.*

# Always false condition
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE 1 = 0;
----
0

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE 1 = 0;
----
analyzed_plan	<REGEX>:.*EMPTY_RESULT.*

# Impossible string condition
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE department = 'Engineering' AND department = 'Sales';
----
0

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE department = 'Engineering' AND department = 'Sales';
----
analyzed_plan	<REGEX>:.*EMPTY_RESULT.*

# Test 1.3: FilterCombiner Partial Handling
# These test cases where FilterCombiner handles some but not all expressions
# Should verify correct fallback to recursive processing

# Simple comparison + unsupported LIKE with leading wildcard
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 AND name LIKE '%pattern';
----
0

# Note: This should fall back to recursive processing since LIKE with leading wildcard is not supported
# But should still be able to push down the id = 100 part
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 AND name LIKE '%pattern';
----
analyzed_plan	<REGEX>:.*Total Files Read: 1.*

# Mixed pushable and unpushable conditions  
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE category = 2 AND name LIKE '%complex';
----
0

# Should push down category = 2 and process LIKE at row level
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE category = 2 AND name LIKE '%complex';
----
analyzed_plan	<REGEX>:.*Total Files Read: 3.*

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE category = 1 AND name LIKE 'name_%';
----
analyzed_plan	<REGEX>:.*Total Files Read: 2.*

# Verify that partial pushdown still produces correct results
# Test with a condition that actually matches some rows
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE category = 1 AND name LIKE 'name_%';
----
200

# Test with OR condition where one side has unsupported expression
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 OR name LIKE '%unsupported';
----
1

# Should still be able to optimize the id = 100 part
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 OR name LIKE '%unsupported';
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# ===== Complex Expression Processing Tests =====

# Test 2.1: AND Conjunction Processing
# Test ProcessAndConjunction logic with various combinations

# Both pushable conditions, same table
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 AND category = 2;
----
0

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 AND category = 2;
----
analyzed_plan	<REGEX>:.*Total Files Read: 1.*

# Both pushable conditions, different columns with results
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id > 500 AND department = 'Engineering';
----
200

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id > 500 AND department = 'Engineering';
----
analyzed_plan	<REGEX>:.*Total Files Read: 1.*

# Mixed pushable and unpushable conditions
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 AND name LIKE '%unsupported';
----
0

# Should push down id = 100 and process LIKE at row level
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 AND name LIKE '%unsupported';
----
analyzed_plan	<REGEX>:.*Total Files Read: 1.*

# Unsatisfiable AND condition
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 AND id = 200;
----
0

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 AND id = 200;
----
analyzed_plan	<REGEX>:.*EMPTY_RESULT.*

# Complex AND with multiple conditions
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id > 100 AND id < 300 AND category = 2;
----
100

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id > 100 AND id < 200 AND category = 2;
----
analyzed_plan	<REGEX>:.*Total Files Read: 1.*

# Test 2.2: OR Disjunction Processing
# Test ProcessOrDisjunction logic and satisfiability tracking

# Both pushable, same column
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 OR id = 200;
----
2

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 OR id = 200;
----
analyzed_plan	<REGEX>:.*Total Files Read: 2.*

# Both pushable, different columns
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 OR category = 5;
----
201

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 OR category = 5;
----
analyzed_plan	<REGEX>:.*Total Files Read: 3.*

# Mixed pushable and unpushable conditions
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 OR name LIKE '%unsupported';
----
1

# Cannot fully optimize due to unpushable LIKE, but should still benefit from partial pushdown
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 OR name LIKE '%unsupported';
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# One unsatisfiable branch in OR
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 OR (id = 200 AND 1 = 0);
----
1

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 100 OR (id = 200 AND 1 = 0);
----
analyzed_plan	<REGEX>:.*Total Files Read: 1.*

# All branches unsatisfiable
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE (id = 100 AND 1 = 0) OR (id = 200 AND 1 = 0);
----
0

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE (id = 100 AND 1 = 0) OR (id = 200 AND 1 = 0);
----
analyzed_plan	<REGEX>:.*EMPTY_RESULT.*

# Test 2.3: Nested Complex Expressions
# Test deeply nested AND/OR combinations

# Nested AND within OR
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE (id = 100 AND category = 1) OR (id = 200 AND category = 2);
----
2

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE (id = 100 AND category = 1) OR (id = 200 AND category = 2);
----
analyzed_plan	<REGEX>:.*Total Files Read: 2.*

# Nested OR within AND
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE (id > 100 OR category = 1) AND (price < 500.0 OR status = 'active');
----
463

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE (id > 100 OR category = 1) AND (price < 500.0 OR status = 'active');
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# Complex triple nested expression
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE ((id = 100 OR id = 200) AND category = 2) OR (price > 700 AND status != 'inactive');
----
14

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE ((id = 100 OR id = 200) AND category = 2) OR (price > 700 AND status != 'inactive');
----
analyzed_plan	<REGEX>:.*Total Files Read: 3.*

# Test 2.4: Cross-Column Equality Restriction Propagation
# Test that equality conditions between columns extend restrictions appropriately

# user_id = constant AND user_id = group_id should propagate constant to group_id
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE user_id = 150 AND user_id = group_id;
----
0

# Note: No matches expected since Files 1&3 have user_id=group_id but different ranges
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE user_id = 150 AND user_id = group_id;
----
analyzed_plan	<REGEX>:.*Total Files Read: 0.*

# group_id > constant AND user_id = group_id should propagate constraint to user_id
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE group_id > 200 AND user_id = group_id;
----
200

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE group_id > 200 AND user_id = group_id;
----
analyzed_plan	<REGEX>:.*Total Files Read: 3.*

# String equality propagation: department = constant AND department = location
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE department = 'Engineering' AND department = location;
----
0

# No matches since location is always different from department in our test data
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE department = 'Engineering' AND department = location;
----
analyzed_plan	<REGEX>:.*Total Files Read: 0.*

# Numeric equality propagation: price > constant AND price = rating (scaled comparison)
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE price > 50.0 AND price = rating;
----
0

# No exact matches expected due to different scaling in test data
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE price > 50.0 AND price = rating;
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# Temporal equality propagation: created_at > constant AND created_at = updated_at
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE created_at > '2023-03-01' AND created_at = updated_at;
----
340

# There's room for further pushdown here
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE created_at > '2023-03-01' AND created_at = updated_at;
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# ===== Statistics-Based Filter Generation Tests =====

# Test 3.1: Numeric Comparison Statistics
# Test min/max statistics usage for different numeric types

# Integer equality - should use BETWEEN min_value AND max_value
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 150;
----
1

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id = 150;
----
analyzed_plan	<REGEX>:.*Total Files Read: 1.*

# Integer not equal - currently not supported (returns empty filter)
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id != 150;
----
999

# Should read all files since != is not pushed down via statistics
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id != 150;
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# Integer greater than or equal - should use max_value >= constant
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id >= 500;
----
500

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id >= 599;
----
analyzed_plan	<REGEX>:.*Total Files Read: 3.*

# Integer greater than - should use max_value > constant
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id > 500;
----
499

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id > 599;
----
analyzed_plan	<REGEX>:.*Total Files Read: 2.*

# Integer less than or equal - should use min_value <= constant
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id <= 300;
----
301

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id <= 300;
----
analyzed_plan	<REGEX>:.*Total Files Read: 2.*

# Integer less than - should use min_value < constant
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id < 300;
----
300

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id < 300;
----
analyzed_plan	<REGEX>:.*Total Files Read: 2.*

# Decimal comparison statistics
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE price = 250.0;
----
1

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE price = 250.0;
----
analyzed_plan	<REGEX>:.*Total Files Read: 1.*

query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE price >= 600.0;
----
216

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE price >= 600.0;
----
analyzed_plan	<REGEX>:.*Total Files Read: 3.*

# Test 3.2: String Comparison Statistics
# Test string statistics with proper casting

# String equality with casting
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE name = 'name_5';
----
100

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE name = 'name_5';
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# String range comparisons
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE name >= 'name_5';
----
500

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE name >= 'name_5';
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# String equality for status field
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE status = 'active';
----
250

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE status = 'active';
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# Department string equality
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE department = 'Engineering';
----
400

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE department = 'Engineering';
----
analyzed_plan	<REGEX>:.*Total Files Read: 2.*

# IN clause expansion to OR conditions
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE status IN ('active', 'pending');
----
500

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE status IN ('active', 'pending');
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# Test 3.3: Float/Double Special Values
# Test NaN and infinity handling in statistics

# Normal double value equality
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE score = 50.0;
----
1

# IS NOT NULL on same column
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE optional_field IS NOT NULL;
----
676

# Should use value_count > 0 check
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE optional_field IS NOT NULL;
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# IS NULL on low-null column (required_field has ~5% nulls)
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE required_field IS NULL;
----
47

# Should still check null_count > 0
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE required_field IS NULL;
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# IS NOT NULL on low-null column
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE required_field IS NOT NULL;
----
953

# Should check value_count > 0
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE required_field IS NOT NULL;
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# Combined NULL and value conditions
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id > 599 AND optional_field IS NOT NULL;
----
293

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id > 500 AND optional_field IS NOT NULL;
----
analyzed_plan	<REGEX>:.*Total Files Read: 3.*

# ===== TableFilter Type Coverage Tests =====

# Test 4.1: Constant Filter Types
# Test all supported constant comparison types

# COMPARE_EQUAL constant filter
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE category = 3;
----
200

# This has to read file 5 as well because the range of it includes 3
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE category = 3;
----
analyzed_plan	<REGEX>:.*Total Files Read: 3.*

# COMPARE_GREATERTHAN constant filter
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE category > 3;
----
400

# COMPARE_GREATERTHANOREQUALTO constant filter
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE category >= 3;
----
600

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE category >= 3;
----
analyzed_plan	<REGEX>:.*Total Files Read: 4.*

# COMPARE_LESSTHAN constant filter
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE category < 3;
----
400

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE category < 3;
----
analyzed_plan	<REGEX>:.*Total Files Read: 3.*

# COMPARE_LESSTHANOREQUALTO constant filter
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE category <= 3;
----
600

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE category <= 3;
----
analyzed_plan	<REGEX>:.*Total Files Read: 4.*

# COMPARE_NOTEQUAL constant filter (currently not supported for pushdown)
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE category != 3;
----
800

# Should read all files since != is not pushed down
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE category != 3;
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# Test 4.2: Conjunction Filter Types
# Test ConjunctionAndFilter and ConjunctionOrFilter processing

# ConjunctionAndFilter - multiple conditions ANDed together
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE category = 2 AND status = 'active' AND price > 100.0;
----
50

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE category = 1 AND status = 'active' AND price > 100.0;
----
analyzed_plan	<REGEX>:.*Total Files Read: 2.*

# ConjunctionOrFilter - multiple conditions ORed together  
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE status = 'active' OR status = 'pending' OR status = 'inactive';
----
750

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE status = 'active' OR status = 'pending' OR status = 'inactive';
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# Mixed conjunction with AND and OR
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE (category = 1 OR category = 2) AND (status = 'active' OR status = 'pending');
----
300

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE (category = 1 OR category = 2) AND (status = 'active' OR status = 'pending');
----
analyzed_plan	<REGEX>:.*Total Files Read: 3.*

# Test 4.3: IN Filter Processing
# Test IN clause expansion to OR conditions

# Integer IN clause
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id IN (100, 200, 300);
----
3

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id IN (100, 200, 300);
----
analyzed_plan	<REGEX>:.*Total Files Read: 2.*

# String IN clause
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE status IN ('active', 'pending', 'inactive');
----
750

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE status IN ('active', 'pending', 'inactive');
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# Category IN clause with limited values
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE category IN (1, 2, 5);
----
600

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE category IN (1, 2, 5);
----
analyzed_plan	<REGEX>:.*Total Files Read: 4.*

# Single value IN clause (should behave like equality)
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id IN (100);
----
1

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id IN (100);
----
analyzed_plan	<REGEX>:.*Total Files Read: 1.*

# Empty IN clause (should return no results)
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id IN (1000);
----
0

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id IN (1000);
----
analyzed_plan	<REGEX>:.*EMPTY_RESULT.*

# Large IN clause with many values
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE id IN (10, 50, 100, 150, 200, 250, 300, 350, 400, 450);
----
10

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE id IN (10, 50, 100, 150, 200, 250, 300, 350, 400, 450);
----
analyzed_plan	<REGEX>:.*Total Files Read: 3.*

# Test 4.4: Optional Filter Unwrapping
# Test OptionalFilter delegation

# Basic optional filter (this tests the unwrapping mechanism)
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE department = 'Sales';
----
400

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE department = 'Sales';
----
analyzed_plan	<REGEX>:.*Total Files Read: 2.*

# Combined optional filter with other conditions
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE department = 'Marketing' AND price < 600.0;
----
100

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE department = 'Marketing' AND price < 600.0;
----
analyzed_plan	<REGEX>:.*Total Files Read: 1.*

# Test 4.5: Complex Filter Combinations
# Test combinations of different filter types working together

# Constant + IN + AND conjunction
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE category > 2 AND status IN ('active', 'pending') AND price >= 400.0;
----
200

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE category > 2 AND status IN ('active', 'pending') AND price >= 400.0;
----
analyzed_plan	<REGEX>:.*Total Files Read: 4.*

# OR with IN clause and equality
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE department = 'Engineering' OR category IN (1, 5);
----
600

# Improvement possible here, it doesn't seem that this filter even gets to the complex pushdown
query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE department = 'Engineering' OR category IN (1, 5);
----
analyzed_plan	<REGEX>:.*Total Files Read: 5.*

# Complex nested with multiple filter types
query I
SELECT COUNT(*) FROM ducklake.filter_test WHERE (id > 500 AND status IN ('active', 'inactive')) OR (category <= 2 AND price < 300.0);
----
369

query II
EXPLAIN ANALYZE SELECT COUNT(*) FROM ducklake.filter_test WHERE (id > 500 AND status IN ('active', 'inactive')) OR (category <= 2 AND price < 300.0);
----
analyzed_plan	<REGEX>:.*Total Files Read: 4.*
