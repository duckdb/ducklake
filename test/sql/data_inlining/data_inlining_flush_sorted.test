# name: test/sql/data_inlining/data_inlining_flush_sorted.test
# description: test flushing inlined data to disk when SET SORTED BY is in use
# group: [data_inlining]

require ducklake

require parquet

test-env DUCKLAKE_CONNECTION __TEST_DIR__/{UUID}.db

test-env DATA_PATH __TEST_DIR__


statement ok
ATTACH 'ducklake:${DUCKLAKE_CONNECTION}' AS ducklake (DATA_PATH '${DATA_PATH}/ducklake_inlining_flush_data', DATA_INLINING_ROW_LIMIT 10)

statement ok
CREATE TABLE ducklake.test(i INTEGER);

query I
SELECT COUNT(*) FROM ducklake.test
----
0

loop i 0 10

statement ok
INSERT INTO ducklake.test VALUES (${i})

endloop

# all data is inlined
query I
SELECT COUNT(*) FROM GLOB('${DATA_PATH}/ducklake_inlining_files/**')
----
0

query I
SELECT COUNT(*) FROM ducklake.test
----
10

query III
SELECT rowid, snapshot_id, * FROM ducklake.test ORDER BY ALL
----
0	2	0
1	3	1
2	4	2
3	5	3
4	6	4
5	7	5
6	8	6
7	9	7
8	10	8
9	11	9

query III
SELECT rowid, snapshot_id, * FROM ducklake.test AT (version => 4) ORDER BY ALL
----
0	2	0
1	3	1
2	4	2

query IIII
FROM ducklake.table_changes('test', 3, 5) ORDER BY ALL
----
3	1	insert	1
4	2	insert	2
5	3	insert	3

statement ok
ALTER TABLE ducklake.test SET SORTED BY (i DESC);

statement ok
BEGIN

# flush inlined data
statement ok
CALL ducklake_flush_inlined_data('ducklake', table_name => 'test')

query I
SELECT COUNT(*) FROM ducklake.test
----
10

# Ordering should reflect the 'i DESC'
query III
SELECT rowid, snapshot_id, * FROM ducklake.test
----
9	11	9
8	10	8
7	9	7
6	8	6
5	7	5
4	6	4
3	5	3
2	4	2
1	3	1
0	2	0

statement ok
COMMIT

query II
SELECT snapshot_id, changes FROM ducklake.snapshots() WHERE snapshot_id IN (2, 13) ORDER BY snapshot_id
----
2	{inlined_insert=[1]}
13	{flushed_inlined=[1]}

# we now have one file
query I
SELECT COUNT(*) FROM GLOB('${DATA_PATH}/ducklake_inlining_flush_data/**')
----
1

# flushing inlined data has no changes
query IIII
FROM ducklake.table_changes('test', 11, 13) ORDER BY ALL
----

# Ordering should reflect the 'i DESC'
query III
SELECT rowid, snapshot_id, * FROM ducklake.test
----
9	11	9
8	10	8
7	9	7
6	8	6
5	7	5
4	6	4
3	5	3
2	4	2
1	3	1
0	2	0

query I
SELECT * FROM ducklake.test AT (version => 4) ORDER BY ALL
----
0
1
2

# we can still access other change feeds
query IIII
FROM ducklake.table_changes('test', 2, 5) ORDER BY ALL
----
2	0	insert	0
3	1	insert	1
4	2	insert	2
5	3	insert	3

# FIXME: this does not work correctly
mode skip

query IIII
FROM ducklake.table_changes('test', 3, 5) ORDER BY ALL
----
3	1	insert	1
4	2	insert	2
5	3	insert	3

mode unskip

query III
SELECT rowid, snapshot_id, * FROM ducklake.test AT (version => 4) ORDER BY ALL
----
0	2	0
1	3	1
2	4	2

# Test with an alter table set sorted within the same transaction
statement ok
CREATE TABLE ducklake.test2(i INTEGER);

query I
SELECT COUNT(*) FROM ducklake.test2
----
0

loop i 0 10

statement ok
INSERT INTO ducklake.test2 VALUES (${i})

endloop

statement ok
BEGIN

# Ensure that we will respect a sort set within the same transaction
statement ok
ALTER TABLE ducklake.test2 SET SORTED BY (i DESC);

# flush inlined data
statement ok
CALL ducklake_flush_inlined_data('ducklake', table_name => 'test2')

query I
SELECT COUNT(*) FROM ducklake.test2
----
10

# Ordering should reflect the 'i DESC'
query III
SELECT rowid, snapshot_id, * FROM ducklake.test2
----
9	24	9
8	23	8
7	22	7
6	21	6
5	20	5
4	19	4
3	18	3
2	17	2
1	16	1
0	15	0

statement ok
COMMIT

# Ordering should reflect the 'i DESC' post commit also
query III
SELECT rowid, snapshot_id, * FROM ducklake.test2
----
9	24	9
8	23	8
7	22	7
6	21	6
5	20	5
4	19	4
3	18	3
2	17	2
1	16	1
0	15	0


# Ensure that other transaction local changes have no impact
statement ok
CREATE TABLE ducklake.test3(i INTEGER);

query I
SELECT COUNT(*) FROM ducklake.test3
----
0

loop i 0 10

statement ok
INSERT INTO ducklake.test3 VALUES (${i})

endloop

statement ok
BEGIN;

statement ok
ALTER TABLE ducklake.test3 SET SORTED BY (i DESC);

# Do some other kind of alter table on that table to make sure that it does not interfere
statement ok
ALTER TABLE ducklake.test3 ADD COLUMN new_column INTEGER;

# flush inlined data
statement ok
CALL ducklake_flush_inlined_data('ducklake', table_name => 'test3')

query I
SELECT COUNT(*) FROM ducklake.test3
----
10

# Ordering should reflect the 'i DESC'
query IIII
SELECT rowid, snapshot_id, * FROM ducklake.test3
----
9	36	9	NULL
8	35	8	NULL
7	34	7	NULL
6	33	6	NULL
5	32	5	NULL
4	31	4	NULL
3	30	3	NULL
2	29	2	NULL
1	28	1	NULL
0	27	0	NULL

statement ok
COMMIT;

# Ordering should reflect the 'i DESC' post commit also
query IIII
SELECT rowid, snapshot_id, * FROM ducklake.test3
----
9	36	9	NULL
8	35	8	NULL
7	34	7	NULL
6	33	6	NULL
5	32	5	NULL
4	31	4	NULL
3	30	3	NULL
2	29	2	NULL
1	28	1	NULL
0	27	0	NULL


# SET SORTED BY then RESET SORTED BY within same transaction
statement ok
CREATE TABLE ducklake.reset_test(i INTEGER);

query I
SELECT COUNT(*) FROM ducklake.reset_test
----
0

loop i 0 10

statement ok
INSERT INTO ducklake.reset_test VALUES (${i})

endloop

statement ok
BEGIN;

statement ok
ALTER TABLE ducklake.reset_test SET SORTED BY (i DESC);

statement ok
ALTER TABLE ducklake.reset_test RESET SORTED BY;

# flush inlined data
statement ok
CALL ducklake_flush_inlined_data('ducklake', table_name => 'reset_test')

query I
SELECT COUNT(*) FROM ducklake.reset_test
----
10

# Ordering should retain the original order
query III
SELECT rowid, snapshot_id, * FROM ducklake.reset_test
----
0	39	0
1	40	1
2	41	2
3	42	3
4	43	4
5	44	5
6	45	6
7	46	7
8	47	8
9	48	9

statement ok
COMMIT;

# Ordering should retain the original order post commit also
query III
SELECT rowid, snapshot_id, * FROM ducklake.reset_test
----
0	39	0
1	40	1
2	41	2
3	42	3
4	43	4
5	44	5
6	45	6
7	46	7
8	47	8
9	48	9


###################################################################################
# SET SORTED BY then rename columns - flush should error on missing columns       #
###################################################################################
statement ok
CREATE TABLE ducklake.renamed_columns_test (unique_id INTEGER, sort_key_1 INTEGER, sort_key_2 VARCHAR);

statement ok
ALTER TABLE ducklake.renamed_columns_test SET SORTED BY (sort_key_1 ASC NULLS LAST, sort_key_2 ASC NULLS LAST);

# Rename the sort columns to completely different names
statement ok
ALTER TABLE ducklake.renamed_columns_test RENAME COLUMN sort_key_1 TO sort_key_1_changed;

statement ok
ALTER TABLE ducklake.renamed_columns_test RENAME COLUMN sort_key_2 TO sort_key_2_changed;

# Insert data (will be inlined initially)
statement ok
INSERT INTO ducklake.renamed_columns_test (unique_id, sort_key_1_changed, sort_key_2_changed)
FROM range(5) t(i)
SELECT
    i AS unique_id,
    i % 2 AS sort_key_1_changed,
    'woot' || i AS sort_key_2_changed
;

# Flush should fail because the sort columns no longer exist
statement error
CALL ducklake_flush_inlined_data('ducklake', table_name => 'renamed_columns_test');
----
Columns in the approx_sort parameter were not found in the DuckLake table

statement ok
ALTER TABLE ducklake.renamed_columns_test SET SORTED BY (sort_key_1_changed ASC NULLS LAST, sort_key_2_changed ASC NULLS LAST);

# Once sorting the new column names, we succeed
statement ok
CALL ducklake_flush_inlined_data('ducklake', table_name => 'renamed_columns_test');